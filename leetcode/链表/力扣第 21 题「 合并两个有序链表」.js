/*这段代码是用于合并两个有序链表的算法实现。使用场景是在处理有序链表时，需要将两个有序链表合并成一个新的有序链表。

逻辑：
1. 创建一个虚拟头节点`dummy`，用于存储合并后的链表。
2. 创建指针`p`指向虚拟头节点。
3. 创建两个指针`p1`和`p2`分别指向两个链表的头节点。
4. 当`p1`和`p2`都不为空时，比较`p1`和`p2`的值，将较小的节点连接到`p`的后面，然后移动较小节点所在链表的指针和`p`指针。
5. 当其中一个链表遍历完后，将另一个链表剩余部分连接到`p`的后面。
6. 返回虚拟头节点的下一个节点，即合并后的链表头节点。

单测用例：
1. 两个链表都为空：
```js
l1 = null;
l2 = null;
```
2. 其中一个链表为空：
```js
l1 = 1 -> 3 -> 5;
l2 = null;
```
3. 两个链表有相同元素：
```js
l1 = 1 -> 3 -> 5;
l2 = 1 -> 2 -> 4;
```
4. 两个链表无相同元素且不交叉：
```js
l1 = 1 -> 3 -> 5;
l2 = 6 -> 8 -> 10;
```
*/
var mergeTwoLists = function(l1, l2) {
    // 合并两个有序链表
    // 虚拟头节点
    let dummy = new ListNode(-1), p = dummy
    var p1 = l1 , p2 = l2
    while (p1 !== null && p2 !== null){
        if(p1.val < p2.val){
            p.next = p1
            p1 = p1.next
        } else {
            p.next = p2
            p2 = p2.next
        }
        p = p.next
    }
    if(p1 === null){
        p.next = p2
    }
    if(p2 === null) {
        p.next = p1
    }
    return dummy.next
};
